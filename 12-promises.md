# Promesas, s√≥lo promesas

Ya estamos llegando casi al final de este primer micro-curso gratuito de MicroBytes.
Gracias por ser parte de este creciente newsletter.

En esta entrega revisaremos como trabajar con promesas.

# ¬øWTF son las promesas?

**Promises es es un objeto para manipular acciones as√≠ncronas dentro de Javascript.**

Javascript es un lenguaje que se ejecuta en el browser con la idea de dar dinamismo al contenido ah√≠ desplegado, esto implica que muchas operaciones se deben dar de forma as√≠ncrona. Dado que los motores de javascript son "Single Threaded", es decir, Javascript no maneja m√∫ltiples hilos es necesario implementar otra estrategia para la asincron√≠a.

una Promise es un objeto que produce un valor que estar√° disponible en alg√∫n momento futuro.

El concepto de promesa, **future** o **deferred** es una construcci√≥n utilizada para ‚Äúsincronizar‚Äù la ejecuci√≥n de instrucciones en lenguajes concurrentes. Este concepto describe un objeto cuyo valor inicial es desconocido.

Este concepto fue acu√±ado hace ya varios a√±os, nacidas (como muchos de los conceptos ‚Äúcool‚Äù que usamos hoy) de la programaci√≥n funcional, siendo quiz√° el primer lenguaje en implementar estas ideas **MultiLisp.**

El desarrollo web trajo nueva vida al concepto dada su naturaleza as√≠ncrona y el modelo de `request-response` utilizado. (solicitar y obtener datos mediante una red donde el solicitante queda a la "espera" de una respuesta).

> Si te interesa saber m√°s del concepto de **promises y futures** puedes encontrar el [paper original aqu√≠](https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.295.9692&rep=rep1&type=pdf)

> O [esta secci√≥n sobre concurrencia](https://www.braveclojure.com/concurrency/) del libro ‚ÄúClojure for the Brave and True‚Äù

Las **Promises** como hoy las conocemos no llegaron a Javascript hasta la versi√≥n ES6, antes de eso todo era un caos y cada quien implementaba comportamientos as√≠ncronos como mejor le pareciera ü§Ø

## ¬øComo funcionan las promesas?

Un promesa es un objeto, y como tal tiene varios atributos y m√©todos que nos permiten trabajar con el. La idea de este objeto es poder acceder y trabajar con el de forma `sincrona` pero cuyo valor es  `asincrono` . Un gato de Schr√∂dinger.

Una promesa tiene 3 estados.

- **Pending:** Es el valor inicial, indicando que est√° a la espera de que ‚Äúel trabajo‚Äù sea realizado.
- **Fullfilled**: Cuando la operaci√≥n se ejecuta de forma existosa.
- **Rejected:** Cuando la operaci√≥n falla de alguna manera.

Ahora bien, estos estados no son expuestos como tal, una promesa es m√°s bien ‚Äúuna caja negra‚Äù en donde s√≥lo la funci√≥n que creo la promesa tiene conocimiento de su propio estado.

### ¬øC√≥mo se crea una promesa?

Suficiente texto, algo de c√≥digo.

```javascript
const sleep = time => new Promise((resolve, reject) => setTimeout(resolve, time));

sleep(3000)

console.log('¬øFuncion√≥ la promesa?')
```

**¬øQu√© ocurre al ejecutar este c√≥digo?**

Nada fuera de lo esperado üòÖ.

En este c√≥digo creamos una funci√≥n `sleep` que recibe el par√°metro `time`, un n√∫mero y retorna una promesa.

Para crear una promesa usamos su constructor y la palabra reserva `new`. La promesa recibe una funci√≥n tipo `callback` como √∫nico argumento. Esta funci√≥n recibe dos par√°metros. `resolve` y `reject`.

Estas funciones `resolve` y `reject` son funciones pre-definidas por el motor de Javascript para manejar los estados de la promesa, nosotros s√≥lo debemos utilizarlas cuando corresponde.

- `resolve` Es utilizado para marcar que el proceso de la promesa termin√≥ de forma exitosa. `resolve` acepta un par√°metro que es retornado como resultado de la ejecuci√≥n.
- `reject` Se usa para determinar cuando el proceso fall√≥, recibe un argumento que indica la raz√≥n del **rechazo** de la promesa.

Entonces, en el c√≥digo, nuestra funci√≥n callback es

```javascript
(resolve, reject) => setTimeout(resolve, time)
```

Donde, `time` es el argumento de la funci√≥n externa (üëã closures otra vez). `setTimeout` ejecutar√° la funci√≥n que se usa como argumento cuando el tiempo definido pase, es decir cuando `time` se cumpla. La funci√≥n que pasamos como argumento es `resolve`, entonces `setTimeout` ejecutar√° `resolve` cuando el tiempo indicado termine.

Esta promesa en particular no falla jamas, por lo que podemos reescribirla as√≠

```javascript
const sleep = time => new Promise((resolve) => setTimeout(resolve, time));
```

Simplemente, eliminando el argumento `reject`.

> **Solo puedes utilizar un s√≥lo resultado o error dentro de una promesa.**

> La funci√≥n "ejecutora" s√≥lo puede tener una llamada **y solo una** a `resolve` o una a  `reject`. Estas funciones cambian el estado de la promesa y este cambio de estado es √∫nico e irreversible.

> **Se recomienda rechazar con errores**

> El m√©todo  `reject` acepta cualquier valor (al igual que `resolve`) pero dado el contexto de  "rechazo‚Äù, se recomienda usar objetos `Error` para indicar la raz√≥n del rechazo.

**Ya, pero ¬øPor qu√© el `console.log` no se ejecuta despu√©s de 3 segundos?**

Esto es por que nuestro c√≥digo no indica que se espere el resultado de la promesa.

Podemos pensar en la promesa como un enlace entre a funci√≥n as√≠ncrona encerrada en la caja negra y el c√≥digo que necesita consumir su resultado. Para esto, `Promise` permite registrar o "suscribirse" a la espera del resultado usando los m√©todos `.then`, `.catch`,  `.finally`.  Una `Promise` es un objeto  `theneable`.

### .then

El m√©todo `.then`  es el m√°s importante y fundamental, es el que nos permite "leer‚Äù el contenido de la caja negra, su sintaxis es

```javascript
promise.then(
	function(result) {},
	function(error) {}
);
```

Es decir, recibe dos argumentos tipo funci√≥n para manejar cada uno de los posibles estados de la promesa: `Fullfilled` y `Rejected` .

El primer argumento es una funci√≥n que se ejecutar√° cuando la promesa es resuelta existosamente, es decir, cuando se usa `resolve`. Esta funci√≥n recibe como argumento el valor pasado al m√©todo `resolve`.

El segundo argumento, es otra funci√≥n pero que esta vez se ejecuta cuando la promesa es rechazada, y recibe como par√°metro la raz√≥n de ese rechazo: el valor pasado a  `reject`.

Entonces, ahora podemos modificar nuestro ejemplo utilizando `.then`

```javascript
const sleep = time => new Promise((resolve, reject) => setTimeout(resolve, time));

sleep(3000).then(() => {
	console.log('¬øFuncion√≥ la promesa?')
})
```

Ahora, concatenamos la ejecuci√≥n de `console.log` a la espera de que la promesa `sleep` se cumpla y en ese momento se muestra el mensaje. Y como en nuestro caso `resolve` no recibe ning√∫n valor, nuestro funci√≥n de "√®xito" tampoco recibe par√°metros y solo se ejecuta.

Es posible separar el manejo de errores y de ejecuciones exitosas para dar un poco de legibilidad al c√≥digo, para eso podemos s√≥lo usar el primer argumento de `.then` y luego usar el siguiente m√©todo: `.catch`

### .catch

Este m√©todo s√≥lo se ejecuta cuando la promesa fue rechazada usando  `reject`. Este m√©todo es un an√°logo de usar `.then(null, f)` (siendo `f` una funci√≥n), existe solo por claridad de su ejecuci√≥n.

¬øPero que ocurre si quieres ejecutar alg√∫n proceso sin importar si la promesa se cumpli√≥ o no?. Entra `.finally`

### .finally

Muy similar a como funciona `.finally` en un bloque `try/catch` este ejecutar√° siempre la funci√≥n que se le pase como argumento, independiente del resultado de la promesa.

- La funci√≥n utilizada dentro de `finally` no recibe argumentos. No sabemos si la promesa fue exitosa o no.
- Puedes concatenar otros ‚Äúmanejadores‚Äù despu√©s de `finally`.

```javascript
const sleep = time => new Promise((resolve, reject) => setTimeout(resolve, time));

sleep(3000)
.finally(() => console.log('Promesa est√° lista'))
.then(() => {
	console.log('¬øFuncion√≥ la promesa?')
})
.catch(err => {
	console.log(erro)
})
```

### Algunas ‚Äúreglas‚Äù

- Una promesa es `thenable`, el objeto siempre otorga un m√©todo `then`
- Una promesa pendiente puede transicionar al estado `fullfilled` or `rejected`
- Una promesa en estado `fullfilled` o  `rejected` se conoce como `settled` y no puede cambiar de estado nuevamente.

### Encadenamiento

Dado que `.then` siempre retorna una nueva promesa, es posible encadenar promesas otorgando mas control sobre como se manejan los resultados y errores, un ejemplo muy utilizado en el mundo real es trabajando con la api `fetch`.

La [api `fetch`](https://developer.mozilla.org/es/docs/Web/API/Fetch_API) es la interfaz nativa de javascript para obtener recursos externos y funciona como una Promesa.

```javascript
const obtenerDatos = () => {
	return fetch('/algunaUrl/)
}

obtenerDatos()
		.then(response => response.json())
		.then(json => json)
		.then(print => {
			console.log(print)
		})
		.catch(error => console.error(error)
```

En este ejemplo creamos una funci√≥n que utiliza la api `fetch` para obtener datos de alg√∫n endpoint y retorna una promesa. Podemos entonces usar `.then` para leer la respuesta obtenida.

La respuesta de una llamada a `fetch` es un objeto `Response` que tiene un m√©todo que permite obtener el cuerpo de la respuesta en forma json y que es en si mismo una promesa.

`.then(response => response.json())`

Usamos el retorno impl√≠cito de la arrow function para retornar inmediatamente la promesa. Luego volvemos a encadenar usando `then` y obtenemos el valor retornado previamente

`. then(json => json)`

En este punto, podemos ya utilizar el valor, pero solo por propositos de demostraci√≥n, lo retornamos `json => json` y volvemos a encadenar `.then(print => {})` creando una nueva funci√≥n que se encarga de imprimir el resultado.

Finalmente encadeamos un `.catch` para capturar cualquier error.

## Algunos otros m√©todos.

El objeto `Promise` nos ofrece algunos otros m√©todos "utilitarios‚Äù:

- `Promise.all` permite obtener el resultado de un grupo de promesas. Recibe como argumento un `iterable` como un arreglo de promesas y espera a que todas las promesas se cumplan o a que una sea rechazada para retornar. Si todas las promesas se cumplen, retornar√° al siguiente`.then` un arreglo con los resultados en el mismo orden que las promesas pasadas como argumento.
- `Promise.race` Tambi√©n recibe un arreglo de promesas pero retorna tan pronto **una** promesa se cumple o rechaza.
- `Promise.allSettled` Tambi√©n recibe un `iterable` de promesas y espera a que todas las promesas hayan terminado sin importar si fueron exitosas o rechazadas. Retorna una promesa con un arreglo de objetos con los resultados de cada promesa pasada como argumento.
- `Promise.any`. Recibe un `iterable` y retorna tan pronto una de las promesas termina exitosamente.

> **Desaf√≠o**

> Escribe una promesa que te permita cargar un script de forma as√≠ncrona y te comunique cuando se ejecuto exitosamente o fall√≥. Puedes usar el [c√≥digo base disponible aqu√≠.](https://jsitor.com/60HE9qayf)

## ¬øC√≥mo se relaciona con React?.

Usar√°s promesas en cada momento con o sin React. Finalmente nuestro trabajo es crear soluciones que implican al menos el 99% de las veces desplegar informaci√≥n que proviene de alg√∫n servicio externo lo que implica asincronicidad y m√∫ltiples estados, siendo las promesas la forma de manejar esa situaci√≥n.

En React es posible te encuentres con algo as√≠ para obtener datos que mostrar dentro de un componente.

```javascript
const Componente = () => {
	const [isLoading, setIsLoading] = React.useState(false)
	const [error, setError ] = React.useState(null)
	const [data, setData] = React.useState(null)
	
	React.useEffect(() => {
		setIsLoading(true)

		// Promesa
		fetch(ALGUNA_URL)
		.then(response => response.json())
		.then(result => setData(result)
		.catch(error => {
			setError(error)
		})
		.finally(() => {
			setIsLoading(false)
		})
	}, [setIsLoading, setData]

	return ........
}
```

En este ejemplo se busca obtener datos desde `ALGUNA_URL` y se encadenan varios `.then`,`.catch` y `.finally` para que el componente responda  a los diferentes estados de la promesa.

